

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bloch_simulator &mdash; Bloch Simulator 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=8d563738"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Bloch Simulator
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Bloch Simulator</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">bloch_simulator</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bloch_simulator</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">bloch_simulator.py - High-level Python API for Bloch equation simulations</span>

<span class="sd">This module provides user-friendly classes and functions for MRI pulse sequence</span>
<span class="sd">simulation using the Bloch equations.</span>

<span class="sd">Author: Your Name</span>
<span class="sd">Date: 2024</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># Import the Cython extension (will be available after building)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">bloch_simulator_cy</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
        <span class="n">simulate_bloch</span><span class="p">,</span> 
        <span class="n">simulate_bloch_parallel</span><span class="p">,</span>
        <span class="n">calculate_signal</span><span class="p">,</span>
        <span class="n">design_rf_pulse</span>
    <span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Cython extension not built. Run &#39;python setup.py build_ext --inplace&#39; first.&quot;</span><span class="p">)</span>
    <span class="c1"># Define dummy functions for testing</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_bloch</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Build the Cython extension first&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_bloch_parallel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Build the Cython extension first&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_signal</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">receiver_phase</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="n">phase_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">receiver_phase</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">mx</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">my</span><span class="p">)</span> <span class="o">*</span> <span class="n">phase_factor</span>
<div class="viewcode-block" id="design_rf_pulse">
<a class="viewcode-back" href="../modules.html#bloch_simulator.design_rf_pulse">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">design_rf_pulse</span><span class="p">(</span><span class="n">pulse_type</span><span class="o">=</span><span class="s1">&#39;rect&#39;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">flip_angle</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span>
                    <span class="n">time_bw_product</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">freq_offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pure-Python fallback for RF design so imports work even without the extension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pulse_type : str</span>
<span class="sd">            Type of pulse (&#39;rect&#39;, &#39;sinc&#39;, &#39;gaussian&#39;, &#39;adiabatic_half&#39;, &#39;adiabatic_full&#39;, &#39;bir4&#39;)</span>
<span class="sd">        duration : float</span>
<span class="sd">            Pulse duration in seconds</span>
<span class="sd">        flip_angle : float</span>
<span class="sd">            Flip angle in degrees</span>
<span class="sd">        time_bw_product : float</span>
<span class="sd">            Time-bandwidth product for sinc/gaussian pulses</span>
<span class="sd">        npoints : int</span>
<span class="sd">            Number of time points</span>
<span class="sd">        freq_offset : float</span>
<span class="sd">            Frequency offset in Hz (default 0). Applies phase modulation: B1 * exp(2πi*f*t)</span>
<span class="sd">            Positive offset shifts the pulse frequency higher.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b1 : complex ndarray</span>
<span class="sd">            Complex B1 field in Gauss</span>
<span class="sd">        time : ndarray</span>
<span class="sd">            Time points in seconds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">/</span> <span class="n">npoints</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="mf">4258.0</span>  <span class="c1"># Hz/Gauss for protons</span>
        <span class="n">flip_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">flip_angle</span><span class="p">)</span>
        <span class="n">target_area</span> <span class="o">=</span> <span class="n">flip_rad</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># integral of B1 over time (Gauss * s)</span>
        <span class="k">if</span> <span class="n">pulse_type</span> <span class="o">==</span> <span class="s1">&#39;rect&#39;</span><span class="p">:</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">target_area</span> <span class="o">/</span> <span class="n">duration</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pulse_type</span> <span class="o">==</span> <span class="s1">&#39;sinc&#39;</span><span class="p">:</span>
            <span class="n">t_centered</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">duration</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">bw</span> <span class="o">=</span> <span class="n">time_bw_product</span> <span class="o">/</span> <span class="n">duration</span>
            <span class="n">envelope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">bw</span> <span class="o">*</span> <span class="n">t_centered</span><span class="p">)</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">envelope</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">envelope</span> <span class="o">*</span> <span class="p">(</span><span class="n">target_area</span> <span class="o">/</span> <span class="n">area</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pulse_type</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
            <span class="n">t_centered</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">duration</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">time_bw_product</span><span class="p">)</span>
            <span class="n">envelope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t_centered</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">envelope</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">envelope</span> <span class="o">*</span> <span class="p">(</span><span class="n">target_area</span> <span class="o">/</span> <span class="n">area</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pulse_type</span> <span class="o">==</span> <span class="s1">&#39;adiabatic_half&#39;</span><span class="p">:</span>
            <span class="c1"># Adiabatic Half Passage (AHP): 90° excitation pulse</span>
            <span class="c1"># Uses hyperbolic secant amplitude + tanh frequency modulation</span>
            <span class="c1"># Magnetization tracks effective field through 90° rotation</span>
            <span class="c1">#</span>
            <span class="c1"># For adiabatic pulses, the flip angle is determined by the adiabaticity</span>
            <span class="c1"># parameter κ = γ·B1_max·T / β, NOT by the pulse area.</span>
            <span class="c1"># The flip_angle parameter controls B1_max to achieve the desired rotation.</span>
            <span class="n">t_centered</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">duration</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">time_bw_product</span>  <span class="c1"># Modulation parameter (typically 4-8)</span>

            <span class="c1"># HS amplitude modulation: A(t) = A0 * sech(beta * t / T)</span>
            <span class="c1"># Normalized amplitude envelope (max = 1.0)</span>
            <span class="n">amplitude</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t_centered</span> <span class="o">/</span> <span class="p">(</span><span class="n">duration</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

            <span class="c1"># Frequency modulation using tanh (standard for HS pulses)</span>
            <span class="c1"># Frequency sweeps from +BW/2 to -BW/2 (or vice versa)</span>
            <span class="c1"># Delta_omega(t) = -omega_max * tanh(beta * t / T)</span>
            <span class="n">bandwidth_hz</span> <span class="o">=</span> <span class="n">time_bw_product</span> <span class="o">/</span> <span class="n">duration</span>
            <span class="n">omega_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">bandwidth_hz</span>  <span class="c1"># Max frequency offset (rad/s)</span>

            <span class="c1"># Frequency sweep using tanh</span>
            <span class="n">freq_modulation</span> <span class="o">=</span> <span class="o">-</span><span class="n">omega_max</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t_centered</span> <span class="o">/</span> <span class="p">(</span><span class="n">duration</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

            <span class="c1"># Integrate to get phase: phi(t) = integral(omega(t) dt)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">/</span> <span class="n">npoints</span>
            <span class="n">instantaneous_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">freq_modulation</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>

            <span class="c1"># Complex B1: A(t) * exp(i*phi(t))</span>
            <span class="n">b1_complex</span> <span class="o">=</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">instantaneous_phase</span><span class="p">)</span>

            <span class="c1"># For adiabatic pulses, scale by flip_angle to control B1_max directly</span>
            <span class="c1"># AHP typically achieves 90° when adiabaticity κ ≈ 5-10</span>
            <span class="c1"># User adjusts flip_angle to control the RF amplitude (B1_max in Gauss)</span>
            <span class="c1"># flip_angle here acts as a B1 scaling factor, not a target rotation</span>
            <span class="n">target_flip_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">flip_angle</span><span class="p">)</span>
            <span class="n">b1_max_gauss</span> <span class="o">=</span> <span class="n">target_flip_rad</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">duration</span><span class="p">)</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">b1_complex</span> <span class="o">*</span> <span class="n">b1_max_gauss</span>

        <span class="k">elif</span> <span class="n">pulse_type</span> <span class="o">==</span> <span class="s1">&#39;adiabatic_full&#39;</span><span class="p">:</span>
            <span class="c1"># Adiabatic Full Passage (AFP): 180° inversion pulse</span>
            <span class="c1"># Uses hyperbolic secant amplitude + tanh frequency modulation</span>
            <span class="c1"># Magnetization follows effective field through full 180° inversion</span>
            <span class="c1">#</span>
            <span class="c1"># For adiabatic pulses, the flip angle is determined by the adiabaticity</span>
            <span class="c1"># parameter κ = γ·B1_max·T / β, NOT by the pulse area.</span>
            <span class="c1"># The flip_angle parameter controls B1_max to achieve the desired rotation.</span>
            <span class="n">t_centered</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">duration</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">time_bw_product</span>  <span class="c1"># Typically 4-8 for good adiabatic condition</span>

            <span class="c1"># HS amplitude modulation: A(t) = A0 * sech(beta * t / T)</span>
            <span class="c1"># Normalized amplitude envelope (max = 1.0)</span>
            <span class="n">amplitude</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t_centered</span> <span class="o">/</span> <span class="p">(</span><span class="n">duration</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

            <span class="c1"># Frequency modulation using tanh (sweeps through full resonance)</span>
            <span class="n">bandwidth_hz</span> <span class="o">=</span> <span class="n">time_bw_product</span> <span class="o">/</span> <span class="n">duration</span>
            <span class="n">omega_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">bandwidth_hz</span>

            <span class="c1"># Full sweep: omega goes from +omega_max to -omega_max</span>
            <span class="n">freq_modulation</span> <span class="o">=</span> <span class="o">-</span><span class="n">omega_max</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t_centered</span> <span class="o">/</span> <span class="p">(</span><span class="n">duration</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

            <span class="c1"># Integrate to get phase</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">/</span> <span class="n">npoints</span>
            <span class="n">instantaneous_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">freq_modulation</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>

            <span class="c1"># Complex B1</span>
            <span class="n">b1_complex</span> <span class="o">=</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">instantaneous_phase</span><span class="p">)</span>

            <span class="c1"># For adiabatic pulses, scale by flip_angle to control B1_max directly</span>
            <span class="c1"># AFP typically achieves 180° when adiabaticity κ ≈ 5-10</span>
            <span class="c1"># User adjusts flip_angle to control the RF amplitude (B1_max in Gauss)</span>
            <span class="c1"># flip_angle here acts as a B1 scaling factor, not a target rotation</span>
            <span class="n">target_flip_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">flip_angle</span><span class="p">)</span>
            <span class="n">b1_max_gauss</span> <span class="o">=</span> <span class="n">target_flip_rad</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">duration</span><span class="p">)</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">b1_complex</span> <span class="o">*</span> <span class="n">b1_max_gauss</span>

        <span class="k">elif</span> <span class="n">pulse_type</span> <span class="o">==</span> <span class="s1">&#39;bir4&#39;</span><span class="p">:</span>
            <span class="c1"># BIR-4 (B1-Insensitive Rotation): Composite adiabatic pulse for arbitrary flip angles</span>
            <span class="c1"># Structure: 4 segments that produce plane rotation insensitive to B1 inhomogeneity</span>
            <span class="c1"># Composed of: AHP - 180° - AHP_inverse - 180°</span>
            <span class="c1"># This implementation uses a simplified HS-based BIR-4</span>
            <span class="c1">#</span>
            <span class="c1"># For adiabatic pulses, the flip angle is determined by the adiabaticity</span>
            <span class="c1"># parameter κ = γ·B1_max·T / β, NOT by the pulse area.</span>
            <span class="c1"># The flip_angle parameter controls B1_max to achieve the desired rotation.</span>

            <span class="n">beta</span> <span class="o">=</span> <span class="n">time_bw_product</span>

            <span class="c1"># Divide pulse into 4 segments</span>
            <span class="n">n_seg</span> <span class="o">=</span> <span class="n">npoints</span> <span class="o">//</span> <span class="mi">4</span>
            <span class="n">t_seg</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">/</span> <span class="mi">4</span>

            <span class="c1"># Segment times</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">[:</span><span class="n">n_seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="n">n_seg</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">n_seg</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">n_seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">n_seg</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">t3</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n_seg</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">n_seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="n">n_seg</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">t4</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">n_seg</span><span class="p">:]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">n_seg</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>

            <span class="n">bandwidth_hz</span> <span class="o">=</span> <span class="n">time_bw_product</span> <span class="o">/</span> <span class="n">t_seg</span>
            <span class="n">omega_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">bandwidth_hz</span>

            <span class="c1"># Segment 1: AHP (90°)</span>
            <span class="n">amp1</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t1</span> <span class="o">/</span> <span class="p">(</span><span class="n">t_seg</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">freq1</span> <span class="o">=</span> <span class="o">-</span><span class="n">omega_max</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t1</span> <span class="o">/</span> <span class="p">(</span><span class="n">t_seg</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">phase1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">freq1</span> <span class="o">*</span> <span class="p">(</span><span class="n">t_seg</span> <span class="o">/</span> <span class="n">n_seg</span><span class="p">))</span>
            <span class="n">b1_seg1</span> <span class="o">=</span> <span class="n">amp1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase1</span><span class="p">)</span>

            <span class="c1"># Segment 2: 180° phase shift + reverse AHP</span>
            <span class="n">amp2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t2</span> <span class="o">/</span> <span class="p">(</span><span class="n">t_seg</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">freq2</span> <span class="o">=</span> <span class="n">omega_max</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t2</span> <span class="o">/</span> <span class="p">(</span><span class="n">t_seg</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># Reversed</span>
            <span class="n">phase2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">freq2</span> <span class="o">*</span> <span class="p">(</span><span class="n">t_seg</span> <span class="o">/</span> <span class="n">n_seg</span><span class="p">))</span> <span class="o">+</span> <span class="n">phase1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">b1_seg2</span> <span class="o">=</span> <span class="n">amp2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">phase2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>  <span class="c1"># 180° phase shift</span>

            <span class="c1"># Segment 3: Inverse AHP</span>
            <span class="n">amp3</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t3</span> <span class="o">/</span> <span class="p">(</span><span class="n">t_seg</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">freq3</span> <span class="o">=</span> <span class="n">omega_max</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t3</span> <span class="o">/</span> <span class="p">(</span><span class="n">t_seg</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">phase3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">freq3</span> <span class="o">*</span> <span class="p">(</span><span class="n">t_seg</span> <span class="o">/</span> <span class="n">n_seg</span><span class="p">))</span> <span class="o">+</span> <span class="n">phase2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">b1_seg3</span> <span class="o">=</span> <span class="n">amp3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase3</span><span class="p">)</span>

            <span class="c1"># Segment 4: 180° phase shift + AHP</span>
            <span class="n">amp4</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t4</span> <span class="o">/</span> <span class="p">(</span><span class="n">t_seg</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">freq4</span> <span class="o">=</span> <span class="o">-</span><span class="n">omega_max</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">t4</span> <span class="o">/</span> <span class="p">(</span><span class="n">t_seg</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">phase4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">freq4</span> <span class="o">*</span> <span class="p">(</span><span class="n">t_seg</span> <span class="o">/</span> <span class="n">n_seg</span><span class="p">))</span> <span class="o">+</span> <span class="n">phase3</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">b1_seg4</span> <span class="o">=</span> <span class="n">amp4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">phase4</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>  <span class="c1"># 180° phase shift</span>

            <span class="c1"># Concatenate segments</span>
            <span class="n">b1_complex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">b1_seg1</span><span class="p">,</span> <span class="n">b1_seg2</span><span class="p">,</span> <span class="n">b1_seg3</span><span class="p">,</span> <span class="n">b1_seg4</span><span class="p">])</span>

            <span class="c1"># Pad if needed due to rounding</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1_complex</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">npoints</span><span class="p">:</span>
                <span class="n">b1_complex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">b1_complex</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npoints</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1_complex</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1_complex</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">npoints</span><span class="p">:</span>
                <span class="n">b1_complex</span> <span class="o">=</span> <span class="n">b1_complex</span><span class="p">[:</span><span class="n">npoints</span><span class="p">]</span>

            <span class="c1"># For adiabatic pulses, scale by flip_angle to control B1_max directly</span>
            <span class="c1"># User adjusts flip_angle to control the RF amplitude (B1_max in Gauss)</span>
            <span class="c1"># flip_angle here acts as a B1 scaling factor, not a target rotation</span>
            <span class="n">target_flip_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">flip_angle</span><span class="p">)</span>
            <span class="n">b1_max_gauss</span> <span class="o">=</span> <span class="n">target_flip_rad</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">duration</span><span class="p">)</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">b1_complex</span> <span class="o">*</span> <span class="n">b1_max_gauss</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown pulse type: </span><span class="si">{</span><span class="n">pulse_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Apply frequency offset as phase modulation</span>
        <span class="k">if</span> <span class="n">freq_offset</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">phase_modulation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq_offset</span> <span class="o">*</span> <span class="n">time</span><span class="p">)</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">b1</span> <span class="o">*</span> <span class="n">phase_modulation</span>

        <span class="k">return</span> <span class="n">b1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">),</span> <span class="n">time</span></div>



<span class="c1"># Import pulse loader (optional - gracefully handle if module not available)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pulse_loader</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_pulse</span><span class="p">,</span> <span class="n">load_pulse_from_file</span><span class="p">,</span> <span class="n">get_pulse_library</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># Define dummy functions if pulse_loader not available</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_pulse</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;pulse_loader module not available&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_pulse_from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;pulse_loader module not available&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_pulse_library</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;pulse_loader module not available&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="TissueParameters">
<a class="viewcode-back" href="../modules.html#bloch_simulator.TissueParameters">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TissueParameters</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for tissue parameters.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Tissue name</span>
<span class="sd">    t1 : float</span>
<span class="sd">        T1 relaxation time in seconds</span>
<span class="sd">    t2 : float</span>
<span class="sd">        T2 relaxation time in seconds</span>
<span class="sd">    t2_star : float</span>
<span class="sd">        T2* relaxation time in seconds</span>
<span class="sd">    density : float</span>
<span class="sd">        Proton density (relative)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">t1</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">t2</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">t2_star</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">density</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    
<div class="viewcode-block" id="TissueParameters.gray_matter">
<a class="viewcode-back" href="../modules.html#bloch_simulator.TissueParameters.gray_matter">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gray_matter</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">field_strength</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gray matter parameters at different field strengths.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">field_strength</span> <span class="o">==</span> <span class="mf">1.5</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="s2">&quot;Gray Matter&quot;</span><span class="p">,</span> <span class="n">t1</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">t2</span><span class="o">=</span><span class="mf">0.100</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">field_strength</span> <span class="o">==</span> <span class="mf">3.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="s2">&quot;Gray Matter&quot;</span><span class="p">,</span> <span class="n">t1</span><span class="o">=</span><span class="mf">1.33</span><span class="p">,</span> <span class="n">t2</span><span class="o">=</span><span class="mf">0.083</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">field_strength</span> <span class="o">==</span> <span class="mf">7.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="s2">&quot;Gray Matter&quot;</span><span class="p">,</span> <span class="n">t1</span><span class="o">=</span><span class="mf">1.92</span><span class="p">,</span> <span class="n">t2</span><span class="o">=</span><span class="mf">0.047</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No data for </span><span class="si">{</span><span class="n">field_strength</span><span class="si">}</span><span class="s2">T&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="TissueParameters.white_matter">
<a class="viewcode-back" href="../modules.html#bloch_simulator.TissueParameters.white_matter">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">white_matter</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">field_strength</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;White matter parameters at different field strengths.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">field_strength</span> <span class="o">==</span> <span class="mf">1.5</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="s2">&quot;White Matter&quot;</span><span class="p">,</span> <span class="n">t1</span><span class="o">=</span><span class="mf">0.65</span><span class="p">,</span> <span class="n">t2</span><span class="o">=</span><span class="mf">0.070</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">field_strength</span> <span class="o">==</span> <span class="mf">3.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="s2">&quot;White Matter&quot;</span><span class="p">,</span> <span class="n">t1</span><span class="o">=</span><span class="mf">0.83</span><span class="p">,</span> <span class="n">t2</span><span class="o">=</span><span class="mf">0.070</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">field_strength</span> <span class="o">==</span> <span class="mf">7.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="s2">&quot;White Matter&quot;</span><span class="p">,</span> <span class="n">t1</span><span class="o">=</span><span class="mf">1.22</span><span class="p">,</span> <span class="n">t2</span><span class="o">=</span><span class="mf">0.046</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No data for </span><span class="si">{</span><span class="n">field_strength</span><span class="si">}</span><span class="s2">T&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="TissueParameters.csf">
<a class="viewcode-back" href="../modules.html#bloch_simulator.TissueParameters.csf">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">csf</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">field_strength</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;CSF parameters at different field strengths.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">field_strength</span> <span class="o">==</span> <span class="mf">1.5</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="s2">&quot;CSF&quot;</span><span class="p">,</span> <span class="n">t1</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">t2</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">field_strength</span> <span class="o">==</span> <span class="mf">3.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="s2">&quot;CSF&quot;</span><span class="p">,</span> <span class="n">t1</span><span class="o">=</span><span class="mf">3.8</span><span class="p">,</span> <span class="n">t2</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">field_strength</span> <span class="o">==</span> <span class="mf">7.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="s2">&quot;CSF&quot;</span><span class="p">,</span> <span class="n">t1</span><span class="o">=</span><span class="mf">4.4</span><span class="p">,</span> <span class="n">t2</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No data for </span><span class="si">{</span><span class="n">field_strength</span><span class="si">}</span><span class="s2">T&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="PulseSequence">
<a class="viewcode-back" href="../modules.html#bloch_simulator.PulseSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PulseSequence</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for MRI pulse sequences.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fov</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.24</span><span class="p">,</span> <span class="n">matrix_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
                 <span class="n">slice_thickness</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize pulse sequence.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fov : float</span>
<span class="sd">            Field of view in meters</span>
<span class="sd">        matrix_size : int</span>
<span class="sd">            Matrix size (assumes square matrix)</span>
<span class="sd">        slice_thickness : float</span>
<span class="sd">            Slice thickness in meters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fov</span> <span class="o">=</span> <span class="n">fov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_size</span> <span class="o">=</span> <span class="n">matrix_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slice_thickness</span> <span class="o">=</span> <span class="n">slice_thickness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="mf">42.576e6</span>  <span class="c1"># Hz/T for protons</span>
        
        <span class="c1"># Calculate resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">fov</span> <span class="o">/</span> <span class="n">matrix_size</span>
        
        <span class="c1"># Initialize sequence components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf_pulses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradients</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adc_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_points</span> <span class="o">=</span> <span class="p">[]</span>
        
<div class="viewcode-block" id="PulseSequence.add_rf_pulse">
<a class="viewcode-back" href="../modules.html#bloch_simulator.PulseSequence.add_rf_pulse">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_rf_pulse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                     <span class="n">phase</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add an RF pulse to the sequence.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf_pulses</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s1">&#39;b1&#39;</span><span class="p">:</span> <span class="n">b1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase</span><span class="p">),</span>
            <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">time</span>
        <span class="p">})</span></div>

        
<div class="viewcode-block" id="PulseSequence.add_gradient">
<a class="viewcode-back" href="../modules.html#bloch_simulator.PulseSequence.add_gradient">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
                    <span class="n">duration</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a gradient to the sequence.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradients</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s1">&#39;axis&#39;</span><span class="p">:</span> <span class="n">axis</span><span class="p">,</span>
            <span class="s1">&#39;amplitude&#39;</span><span class="p">:</span> <span class="n">amplitude</span><span class="p">,</span>
            <span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
            <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">time</span>
        <span class="p">})</span></div>

        
<div class="viewcode-block" id="PulseSequence.compile">
<a class="viewcode-back" href="../modules.html#bloch_simulator.PulseSequence.compile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile the sequence into arrays for simulation.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b1 : ndarray</span>
<span class="sd">            Complex B1 field</span>
<span class="sd">        gradients : ndarray</span>
<span class="sd">            Gradient waveforms [Gx, Gy, Gz]</span>
<span class="sd">        time : ndarray</span>
<span class="sd">            Time points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Implementation depends on specific sequence</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement compile()&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SpinEcho">
<a class="viewcode-back" href="../modules.html#bloch_simulator.SpinEcho">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SpinEcho</span><span class="p">(</span><span class="n">PulseSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Spin echo pulse sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">custom_excitation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">custom_refocusing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">slice_thickness</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
                 <span class="n">slice_gradient_override</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">echo_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rf_freq_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize spin echo sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time in seconds</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time in seconds</span>
<span class="sd">        rf_freq_offset : float</span>
<span class="sd">            RF frequency offset in Hz (default 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">slice_thickness</span><span class="o">=</span><span class="n">slice_thickness</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">=</span> <span class="n">te</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_excitation</span> <span class="o">=</span> <span class="n">custom_excitation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_refocusing</span> <span class="o">=</span> <span class="n">custom_refocusing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="o">=</span> <span class="n">slice_gradient_override</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">echo_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">echo_count</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf_freq_offset</span> <span class="o">=</span> <span class="n">rf_freq_offset</span>
        
<div class="viewcode-block" id="SpinEcho.compile">
<a class="viewcode-back" href="../modules.html#bloch_simulator.SpinEcho.compile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compile spin echo sequence.&quot;&quot;&quot;</span>
        <span class="c1"># Ensure timeline covers all requested echoes (echo spacing = TE)</span>
        <span class="n">min_duration</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">echo_count</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">+</span> <span class="mf">1e-3</span>  <span class="c1"># include some buffer</span>
        <span class="n">total_duration</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="p">,</span> <span class="n">min_duration</span><span class="p">)</span>
        <span class="n">npoints</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">total_duration</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
        
        <span class="c1"># Initialize arrays</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npoints</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
        
        <span class="c1"># 90-degree excitation pulse</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_excitation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exc_b1</span><span class="p">,</span> <span class="n">exc_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_excitation</span>
            <span class="n">exc_b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">exc_b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">n_exc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exc_b1</span><span class="p">),</span> <span class="n">npoints</span><span class="p">)</span>
            <span class="n">b1</span><span class="p">[:</span><span class="n">n_exc</span><span class="p">]</span> <span class="o">=</span> <span class="n">exc_b1</span><span class="p">[:</span><span class="n">n_exc</span><span class="p">]</span>
            <span class="n">exc_duration</span> <span class="o">=</span> <span class="n">n_exc</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exc_pulse</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">design_rf_pulse</span><span class="p">(</span><span class="s1">&#39;sinc&#39;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
                                          <span class="n">flip_angle</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e-3</span><span class="o">/</span><span class="n">dt</span><span class="p">),</span>
                                          <span class="n">freq_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rf_freq_offset</span><span class="p">)</span>
            <span class="n">n_exc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exc_pulse</span><span class="p">)</span>
            <span class="n">b1</span><span class="p">[:</span><span class="n">n_exc</span><span class="p">]</span> <span class="o">=</span> <span class="n">exc_pulse</span>
            <span class="n">exc_duration</span> <span class="o">=</span> <span class="mf">1e-3</span>
            
        <span class="c1"># Refocusing pulse</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_refocusing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_b1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_refocusing</span>
            <span class="n">ref_pulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ref_b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default refocusing: classic 180° sinc</span>
            <span class="n">ref_pulse</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">design_rf_pulse</span><span class="p">(</span><span class="s1">&#39;sinc&#39;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">2e-3</span><span class="p">,</span>
                                          <span class="n">flip_angle</span><span class="o">=</span><span class="mi">180</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">2e-3</span><span class="o">/</span><span class="n">dt</span><span class="p">),</span>
                                          <span class="n">freq_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rf_freq_offset</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">echo_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">echo_count</span><span class="p">):</span>
            <span class="n">ref_time</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">echo_idx</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span>
            <span class="n">ref_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ref_time</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref_start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_pulse</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">npoints</span><span class="p">:</span>
                <span class="n">b1</span><span class="p">[</span><span class="n">ref_start</span><span class="p">:</span><span class="n">ref_start</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_pulse</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ref_pulse</span>
        
        <span class="c1"># Add slice selection gradients</span>
        <span class="c1"># (simplified - real implementation would be more complex)</span>
        <span class="c1"># Slice gradient G (G/cm) = BW(Hz) / (gamma(Hz/G) * thickness(cm))</span>
        <span class="n">bw_hz</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">exc_duration</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">gamma_hz_per_g</span> <span class="o">=</span> <span class="mf">4258.0</span>
        <span class="n">thickness_cm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slice_thickness</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gz_amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gz_amp</span> <span class="o">=</span> <span class="n">bw_hz</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma_hz_per_g</span> <span class="o">*</span> <span class="n">thickness_cm</span><span class="p">)</span>
        <span class="n">gradients</span><span class="p">[:</span><span class="nb">max</span><span class="p">(</span><span class="n">n_exc</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gz_amp</span>
        <span class="k">for</span> <span class="n">echo_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">echo_count</span><span class="p">):</span>
            <span class="n">ref_time</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">echo_idx</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span>
            <span class="n">ref_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ref_time</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref_start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_pulse</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">npoints</span><span class="p">:</span>
                <span class="n">gradients</span><span class="p">[</span><span class="n">ref_start</span><span class="p">:</span><span class="n">ref_start</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_pulse</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gz_amp</span>
        
        <span class="k">return</span> <span class="n">b1</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">time</span></div>
</div>



<div class="viewcode-block" id="SpinEchoTipAxis">
<a class="viewcode-back" href="../modules.html#bloch_simulator.SpinEchoTipAxis">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SpinEchoTipAxis</span><span class="p">(</span><span class="n">PulseSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Spin echo where the refocusing 180 is applied around the axis of the tipped magnetization.</span>

<span class="sd">    Implemented by phase-shifting the 180 pulse by +90 degrees relative to the excitation phase</span>
<span class="sd">    (CPMG-style: 90° about X, 180° about Y).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">custom_excitation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">custom_refocusing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">slice_thickness</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
                 <span class="n">slice_gradient_override</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">echo_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">slice_thickness</span><span class="o">=</span><span class="n">slice_thickness</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">=</span> <span class="n">te</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_excitation</span> <span class="o">=</span> <span class="n">custom_excitation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_refocusing</span> <span class="o">=</span> <span class="n">custom_refocusing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="o">=</span> <span class="n">slice_gradient_override</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">echo_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">echo_count</span><span class="p">))</span>

<div class="viewcode-block" id="SpinEchoTipAxis.compile">
<a class="viewcode-back" href="../modules.html#bloch_simulator.SpinEchoTipAxis.compile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">min_duration</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">echo_count</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">+</span> <span class="mf">1e-3</span>
        <span class="n">total_duration</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tr</span><span class="p">,</span> <span class="n">min_duration</span><span class="p">)</span>
        <span class="n">npoints</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">total_duration</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>

        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npoints</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

        <span class="c1"># Excitation pulse</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_excitation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exc_b1</span><span class="p">,</span> <span class="n">exc_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_excitation</span>
            <span class="n">exc_b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">exc_b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">n_exc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exc_b1</span><span class="p">),</span> <span class="n">npoints</span><span class="p">)</span>
            <span class="n">b1</span><span class="p">[:</span><span class="n">n_exc</span><span class="p">]</span> <span class="o">=</span> <span class="n">exc_b1</span><span class="p">[:</span><span class="n">n_exc</span><span class="p">]</span>
            <span class="n">exc_duration</span> <span class="o">=</span> <span class="n">n_exc</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exc_b1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">design_rf_pulse</span><span class="p">(</span><span class="s1">&#39;sinc&#39;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
                                       <span class="n">flip_angle</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e-3</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
            <span class="n">n_exc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exc_b1</span><span class="p">)</span>
            <span class="n">b1</span><span class="p">[:</span><span class="n">n_exc</span><span class="p">]</span> <span class="o">=</span> <span class="n">exc_b1</span>
            <span class="n">exc_duration</span> <span class="o">=</span> <span class="mf">1e-3</span>
        <span class="c1"># Build a proper 180° refocusing pulse (independent of excitation shape)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_refocusing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_b1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_refocusing</span>
            <span class="n">ref_pulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ref_b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_pulse</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">design_rf_pulse</span><span class="p">(</span><span class="s1">&#39;sinc&#39;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">2e-3</span><span class="p">,</span>
                                          <span class="n">flip_angle</span><span class="o">=</span><span class="mi">180</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">2e-3</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>

        <span class="c1"># Estimate excitation phase from non-zero samples; default to 0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b1</span><span class="p">[:</span><span class="n">n_exc</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">exc_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">b1</span><span class="p">[:</span><span class="n">n_exc</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b1</span><span class="p">[:</span><span class="n">n_exc</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exc_phase</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># 180° refocusing pulses every TE, phase-shifted by +90° relative to excitation</span>
        <span class="n">phase_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">exc_phase</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">))</span>
        <span class="n">ref_pulse</span> <span class="o">=</span> <span class="n">ref_pulse</span> <span class="o">*</span> <span class="n">phase_shift</span>
        <span class="k">for</span> <span class="n">echo_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">echo_count</span><span class="p">):</span>
            <span class="n">ref_time</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">echo_idx</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span>
            <span class="n">ref_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ref_time</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref_start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_pulse</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">npoints</span><span class="p">:</span>
                <span class="n">b1</span><span class="p">[</span><span class="n">ref_start</span><span class="p">:</span><span class="n">ref_start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_pulse</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ref_pulse</span>

        <span class="c1"># Slice-select gradients (reuse SpinEcho logic)</span>
        <span class="n">bw_hz</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">exc_duration</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">gamma_hz_per_g</span> <span class="o">=</span> <span class="mf">4258.0</span>
        <span class="n">thickness_cm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slice_thickness</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gz_amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gz_amp</span> <span class="o">=</span> <span class="n">bw_hz</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma_hz_per_g</span> <span class="o">*</span> <span class="n">thickness_cm</span><span class="p">)</span>
        <span class="n">gradients</span><span class="p">[:</span><span class="nb">max</span><span class="p">(</span><span class="n">n_exc</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gz_amp</span>
        <span class="k">for</span> <span class="n">echo_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">echo_count</span><span class="p">):</span>
            <span class="n">ref_time</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">echo_idx</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span>
            <span class="n">ref_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ref_time</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref_start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_pulse</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">npoints</span><span class="p">:</span>
                <span class="n">gradients</span><span class="p">[</span><span class="n">ref_start</span><span class="p">:</span><span class="n">ref_start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_pulse</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gz_amp</span>

        <span class="k">return</span> <span class="n">b1</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">time</span></div>
</div>



<div class="viewcode-block" id="GradientEcho">
<a class="viewcode-back" href="../modules.html#bloch_simulator.GradientEcho">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GradientEcho</span><span class="p">(</span><span class="n">PulseSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gradient echo pulse sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">flip_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">custom_excitation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">slice_thickness</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span> <span class="n">slice_gradient_override</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rf_freq_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize gradient echo sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time in seconds</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time in seconds</span>
<span class="sd">        flip_angle : float</span>
<span class="sd">            Flip angle in degrees</span>
<span class="sd">        rf_freq_offset : float</span>
<span class="sd">            RF frequency offset in Hz (default 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">slice_thickness</span><span class="o">=</span><span class="n">slice_thickness</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">=</span> <span class="n">te</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flip_angle</span> <span class="o">=</span> <span class="n">flip_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_excitation</span> <span class="o">=</span> <span class="n">custom_excitation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="o">=</span> <span class="n">slice_gradient_override</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf_freq_offset</span> <span class="o">=</span> <span class="n">rf_freq_offset</span>
        
<div class="viewcode-block" id="GradientEcho.compile">
<a class="viewcode-back" href="../modules.html#bloch_simulator.GradientEcho.compile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compile gradient echo sequence.&quot;&quot;&quot;</span>
        <span class="n">npoints</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
        
        <span class="c1"># Initialize arrays</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npoints</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
        
        <span class="c1"># Excitation pulse</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_excitation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exc_b1</span><span class="p">,</span> <span class="n">exc_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_excitation</span>
            <span class="n">exc_b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">exc_b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">n_exc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exc_b1</span><span class="p">),</span> <span class="n">npoints</span><span class="p">)</span>
            <span class="n">b1</span><span class="p">[:</span><span class="n">n_exc</span><span class="p">]</span> <span class="o">=</span> <span class="n">exc_b1</span><span class="p">[:</span><span class="n">n_exc</span><span class="p">]</span>
            <span class="n">exc_duration</span> <span class="o">=</span> <span class="n">n_exc</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exc_pulse</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">design_rf_pulse</span><span class="p">(</span><span class="s1">&#39;sinc&#39;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
                                          <span class="n">flip_angle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flip_angle</span><span class="p">,</span>
                                          <span class="n">npoints</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e-3</span><span class="o">/</span><span class="n">dt</span><span class="p">),</span>
                                          <span class="n">freq_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rf_freq_offset</span><span class="p">)</span>
            <span class="n">b1</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">exc_pulse</span><span class="p">)]</span> <span class="o">=</span> <span class="n">exc_pulse</span>
            <span class="n">exc_duration</span> <span class="o">=</span> <span class="mf">1e-3</span>
        
        <span class="c1"># Slice selection gradient</span>
        <span class="n">thickness_cm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slice_thickness</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="n">bw_hz</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">exc_duration</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">gamma_hz_per_g</span> <span class="o">=</span> <span class="mf">4258.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gz_amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gz_amp</span> <span class="o">=</span> <span class="n">bw_hz</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma_hz_per_g</span> <span class="o">*</span> <span class="n">thickness_cm</span><span class="p">)</span>
        <span class="n">n_exc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">gradients</span><span class="p">[:</span><span class="nb">max</span><span class="p">(</span><span class="n">n_exc</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gz_amp</span>
        
        <span class="c1"># Readout gradient (simplified)</span>
        <span class="n">readout_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5e-3</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">readout_duration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e-3</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">readout_start</span> <span class="o">+</span> <span class="n">readout_duration</span> <span class="o">&lt;</span> <span class="n">npoints</span><span class="p">:</span>
            <span class="n">gradients</span><span class="p">[</span><span class="n">readout_start</span><span class="p">:</span><span class="n">readout_start</span><span class="o">+</span><span class="n">readout_duration</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">5e-3</span>
        
        <span class="k">return</span> <span class="n">b1</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">time</span></div>
</div>



<div class="viewcode-block" id="SliceSelectRephase">
<a class="viewcode-back" href="../modules.html#bloch_simulator.SliceSelectRephase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SliceSelectRephase</span><span class="p">(</span><span class="n">PulseSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple slice-select pulse followed by a rephasing gradient lobe.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">flip_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span>
        <span class="n">pulse_duration</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3e-3</span><span class="p">,</span>
        <span class="n">time_bw_product</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">,</span>
        <span class="n">rephase_duration</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.6e-3</span><span class="p">,</span>
        <span class="n">slice_gradient_override</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">custom_pulse</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flip_angle</span> <span class="o">=</span> <span class="n">flip_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span> <span class="o">=</span> <span class="n">pulse_duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_bw_product</span> <span class="o">=</span> <span class="n">time_bw_product</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rephase_duration</span> <span class="o">=</span> <span class="n">rephase_duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="o">=</span> <span class="n">slice_gradient_override</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_pulse</span> <span class="o">=</span> <span class="n">custom_pulse</span>

<div class="viewcode-block" id="SliceSelectRephase.compile">
<a class="viewcode-back" href="../modules.html#bloch_simulator.SliceSelectRephase.compile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile a slice-select + rephase waveform.</span>

<span class="sd">        The slice gradient area during the RF pulse is rewound with a</span>
<span class="sd">        negative lobe of half the area.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">)</span>

        <span class="c1"># Use custom pulse if provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_pulse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b1</span><span class="p">,</span> <span class="n">pulse_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_pulse</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">n_rf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>
            <span class="c1"># Use actual pulse duration from custom pulse</span>
            <span class="n">pulse_duration</span> <span class="o">=</span> <span class="n">pulse_time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pulse_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pulse_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_rf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)))</span>
            <span class="n">pulse_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span>
            <span class="c1"># RF pulse</span>
            <span class="n">b1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">design_rf_pulse</span><span class="p">(</span>
                <span class="s2">&quot;sinc&quot;</span><span class="p">,</span>
                <span class="n">duration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span><span class="p">,</span>
                <span class="n">flip_angle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flip_angle</span><span class="p">,</span>
                <span class="n">time_bw_product</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_bw_product</span><span class="p">,</span>
                <span class="n">npoints</span><span class="o">=</span><span class="n">n_rf</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="n">n_rephase</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rephase_duration</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)))</span>
        <span class="n">gap_pts</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.2e-3</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)))</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">n_rf</span> <span class="o">+</span> <span class="n">gap_pts</span> <span class="o">+</span> <span class="n">n_rephase</span>

        <span class="c1"># Gradients (Gauss/cm)</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">bw_hz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_bw_product</span> <span class="o">/</span> <span class="n">pulse_duration</span>
        <span class="n">gamma_hz_per_g</span> <span class="o">=</span> <span class="mf">4258.0</span>
        <span class="n">thickness_cm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slice_thickness</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gz_gauss_per_cm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gz_gauss_per_cm</span> <span class="o">=</span> <span class="n">bw_hz</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma_hz_per_g</span> <span class="o">*</span> <span class="n">thickness_cm</span><span class="p">)</span>
        <span class="n">gradients</span><span class="p">[:</span><span class="n">n_rf</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gz_gauss_per_cm</span>

        <span class="c1"># Rephasing lobe with half the area of the excitation lobe</span>
        <span class="n">area_exc</span> <span class="o">=</span> <span class="n">gz_gauss_per_cm</span> <span class="o">*</span> <span class="n">pulse_duration</span>
        <span class="n">rephase_amp</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">area_exc</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_rephase</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">start_rephase</span> <span class="o">=</span> <span class="n">n_rf</span> <span class="o">+</span> <span class="n">gap_pts</span>
        <span class="n">gradients</span><span class="p">[</span><span class="n">start_rephase</span><span class="p">:</span><span class="n">start_rephase</span> <span class="o">+</span> <span class="n">n_rephase</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rephase_amp</span>
        <span class="c1"># Zero-pad B1 to match total time length</span>
        <span class="n">b1_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">b1_full</span><span class="p">[:</span><span class="n">n_rf</span><span class="p">]</span> <span class="o">=</span> <span class="n">b1</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="k">return</span> <span class="n">b1_full</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">time</span></div>
</div>



<div class="viewcode-block" id="CustomPulse">
<a class="viewcode-back" href="../modules.html#bloch_simulator.CustomPulse">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CustomPulse</span><span class="p">(</span><span class="n">PulseSequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Custom pulse sequence loaded from a file.</span>

<span class="sd">    Supports Bruker JCAMP-DX format (.exc) and other waveform files.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pulse_source</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="n">gradients</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">slice_gradient_override</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_b1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize custom pulse sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pulse_source : str or Path</span>
<span class="sd">            Either a pulse name (e.g., &#39;bruker/13C_Ultimate_SPSP_Pulse_QuEMRT&#39;)</span>
<span class="sd">            or a file path to an RF pulse file</span>
<span class="sd">        gradients : ndarray, optional</span>
<span class="sd">            Custom gradient waveforms (ntime, 3). If None, no gradients applied.</span>
<span class="sd">        slice_gradient_override : float, optional</span>
<span class="sd">            Override slice gradient amplitude (Gauss/cm)</span>
<span class="sd">        scale_b1 : float, optional</span>
<span class="sd">            Scale factor for B1 amplitude (default: 1.0)</span>
<span class="sd">        **kwargs : optional</span>
<span class="sd">            Additional arguments passed to PulseSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_source</span> <span class="o">=</span> <span class="n">pulse_source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_gradients</span> <span class="o">=</span> <span class="n">gradients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slice_gradient_override</span> <span class="o">=</span> <span class="n">slice_gradient_override</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_b1</span> <span class="o">=</span> <span class="n">scale_b1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Load the pulse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_pulse</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_pulse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load pulse from file or library.&quot;&quot;&quot;</span>
        <span class="n">pulse_source</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_source</span><span class="p">)</span>

        <span class="c1"># Try to load from library first (if it looks like a library name)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Path</span><span class="p">(</span><span class="n">pulse_source</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">load_pulse</span><span class="p">(</span><span class="n">pulse_source</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="c1"># Try to load as a direct file path</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">load_pulse_from_file</span><span class="p">(</span><span class="n">pulse_source</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">FileNotFoundError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not load pulse from &#39;</span><span class="si">{</span><span class="n">pulse_source</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Ensure the file exists or the pulse name is in the library.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

<div class="viewcode-block" id="CustomPulse.compile">
<a class="viewcode-back" href="../modules.html#bloch_simulator.CustomPulse.compile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile the custom pulse sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : float</span>
<span class="sd">            Time step for resampling (if needed)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b1 : ndarray</span>
<span class="sd">            Complex B1 field (Gauss)</span>
<span class="sd">        gradients : ndarray</span>
<span class="sd">            Gradient waveforms (ntime, 3) in Gauss/cm</span>
<span class="sd">        time : ndarray</span>
<span class="sd">            Time points in seconds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Resample B1 if needed</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Check if resampling is needed</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">actual_dt</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">actual_dt</span> <span class="o">=</span> <span class="n">dt</span>

        <span class="k">if</span> <span class="n">actual_dt</span> <span class="o">!=</span> <span class="n">dt</span> <span class="ow">and</span> <span class="n">dt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Resample to new dt</span>
            <span class="n">new_npoints</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
            <span class="n">new_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_npoints</span><span class="p">)</span>
            <span class="c1"># Simple linear interpolation</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">new_time</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">new_time</span>

        <span class="c1"># Apply B1 scaling</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">b1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_b1</span>

        <span class="c1"># Handle gradients</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_gradients</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_gradients</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No gradients</span>
            <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Ensure gradient shape matches B1 length</span>
        <span class="k">if</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Broadcast single gradient to all points</span>
                <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">gradients</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Resample gradients to match B1 length</span>
                <span class="n">old_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">new_time_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">))</span>
                <span class="n">gradients_resampled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">gradients_resampled</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                        <span class="n">new_time_idx</span><span class="p">,</span> <span class="n">old_time</span><span class="p">,</span> <span class="n">gradients</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="n">gradients</span> <span class="o">=</span> <span class="n">gradients_resampled</span>

        <span class="k">return</span> <span class="n">b1</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">time</span></div>
</div>



<div class="viewcode-block" id="BlochSimulator">
<a class="viewcode-back" href="../modules.html#bloch_simulator.BlochSimulator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BlochSimulator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    High-level interface for Bloch equation simulations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Bloch simulator.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_parallel : bool</span>
<span class="sd">            Use parallel processing</span>
<span class="sd">        num_threads : int</span>
<span class="sd">            Number of threads for parallel processing</span>
<span class="sd">        verbose : bool</span>
<span class="sd">            Print progress messages</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_parallel</span> <span class="o">=</span> <span class="n">use_parallel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span> <span class="o">=</span> <span class="kc">None</span>
    
<div class="viewcode-block" id="BlochSimulator.log_message">
<a class="viewcode-back" href="../modules.html#bloch_simulator.BlochSimulator.log_message">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">log_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print a message if verbose mode is enabled.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="BlochSimulator.simulate">
<a class="viewcode-back" href="../modules.html#bloch_simulator.BlochSimulator.simulate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">sequence</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PulseSequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                 <span class="n">tissue</span><span class="p">:</span> <span class="n">TissueParameters</span><span class="p">,</span>
                 <span class="n">positions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">frequencies</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">initial_magnetization</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate MRI signal using Bloch equations.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sequence : PulseSequence or tuple</span>
<span class="sd">            Pulse sequence object or (b1, gradients, time) tuple</span>
<span class="sd">        tissue : TissueParameters</span>
<span class="sd">            Tissue parameters</span>
<span class="sd">        positions : ndarray, optional</span>
<span class="sd">            Spatial positions [x, y, z] in meters</span>
<span class="sd">        frequencies : ndarray, optional  </span>
<span class="sd">            Off-resonance frequencies in Hz</span>
<span class="sd">        initial_magnetization : ndarray, optional</span>
<span class="sd">            Initial magnetization state</span>
<span class="sd">        dt : float</span>
<span class="sd">            Time step for compilation</span>
<span class="sd">        mode : int</span>
<span class="sd">            Simulation mode (0: endpoint, 2: time-resolved)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing:</span>
<span class="sd">            - &#39;mx&#39;, &#39;my&#39;, &#39;mz&#39;: Magnetization components</span>
<span class="sd">            - &#39;signal&#39;: Complex MRI signal</span>
<span class="sd">            - &#39;time&#39;: Time points</span>
<span class="sd">            - &#39;positions&#39;: Positions used</span>
<span class="sd">            - &#39;frequencies&#39;: Frequencies used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Compile sequence if needed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">PulseSequence</span><span class="p">):</span>
            <span class="n">b1</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b1</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">sequence</span>
        
        <span class="c1"># Sanitize and standardize inputs to avoid buffer errors from Cython</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;B1 array must be 1D after squeezing, got shape </span><span class="si">{</span><span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># design_rf_pulse already returns Gauss; keep units unchanged</span>
        <span class="n">b1_gauss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>

        <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gradients</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gradients</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">gradients</span> <span class="o">=</span> <span class="n">gradients</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gradients</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gradients must be 2D, got </span><span class="si">{</span><span class="n">gradients</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">D with shape </span><span class="si">{</span><span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">gradients</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gradients</span> <span class="o">=</span> <span class="n">gradients</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b1_gauss</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gradients length (</span><span class="si">{</span><span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">) must match B1 length (</span><span class="si">{</span><span class="n">b1_gauss</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="c1"># Gradients expected in Gauss/cm already</span>
        <span class="n">gradients_gauss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">gradients</span><span class="p">)</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time array must be 1D after squeezing, got shape </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b1_gauss</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time length (</span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">) must match B1 length (</span><span class="si">{</span><span class="n">b1_gauss</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="c1"># Default positions and frequencies</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">positions_cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">positions</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># m -&gt; cm</span>

        <span class="k">if</span> <span class="n">frequencies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">])</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>

        <span class="c1"># Prepare initial magnetization if provided (shape expected: 3 x (npos*nfreq))</span>
        <span class="n">m_init</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">initial_magnetization</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">initial_magnetization</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">nfnpos</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">frequencies</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">init_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">init_arr</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">m_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">vec</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nfnpos</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">init_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">init_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">init_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">m_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nfnpos</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Initial magnetization must be scalar or length-3 vector.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">init_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Accept (3, nfnpos) or (nfnpos, 3)</span>
                <span class="k">if</span> <span class="n">init_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">nfnpos</span><span class="p">):</span>
                    <span class="n">m_init</span> <span class="o">=</span> <span class="n">init_arr</span>
                <span class="k">elif</span> <span class="n">init_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nfnpos</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">m_init</span> <span class="o">=</span> <span class="n">init_arr</span><span class="o">.</span><span class="n">T</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initial magnetization shape must be (3, npos*nfreq); got </span><span class="si">{</span><span class="n">init_arr</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Initial magnetization must be scalar, length-3 vector, or (3, npos*nfreq) array.&quot;</span><span class="p">)</span>
            <span class="n">m_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">m_init</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Guard against unreasonably large allocations in time-resolved mode</span>
        <span class="n">ntout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">total_points</span> <span class="o">=</span> <span class="n">ntout</span> <span class="o">*</span> <span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">frequencies</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">total_points</span> <span class="o">&gt;</span> <span class="mf">5e7</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Requested simulation is too large (</span><span class="si">{</span><span class="n">total_points</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2"> samples). &quot;</span>
                <span class="s2">&quot;Increase the time step, reduce positions/frequencies, or use Endpoint mode.&quot;</span>
            <span class="p">)</span>
            
        <span class="c1"># Time intervals</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dt_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="n">dt_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt_array</span><span class="p">,</span> <span class="n">dt_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dt</span><span class="p">])</span>
            
        <span class="c1"># Run simulation</span>
        <span class="c1"># The OpenMP path can be unstable on some macOS/Python builds; keep the</span>
        <span class="c1"># threshold high to avoid crashes for small/medium workloads.</span>
        <span class="n">parallel_threshold</span> <span class="o">=</span> <span class="mi">256</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_parallel</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">parallel_threshold</span><span class="p">:</span>
            <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span> <span class="o">=</span> <span class="n">simulate_bloch_parallel</span><span class="p">(</span>
                <span class="n">b1_gauss</span><span class="p">,</span> <span class="n">gradients_gauss</span><span class="p">,</span> <span class="n">dt_array</span><span class="p">,</span>
                <span class="n">tissue</span><span class="o">.</span><span class="n">t1</span><span class="p">,</span> <span class="n">tissue</span><span class="o">.</span><span class="n">t2</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span>
                <span class="n">positions_cm</span><span class="p">,</span> <span class="n">initial_magnetization</span><span class="p">,</span>
                <span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span> <span class="o">=</span> <span class="n">simulate_bloch</span><span class="p">(</span>
                <span class="n">b1_gauss</span><span class="p">,</span> <span class="n">gradients_gauss</span><span class="p">,</span> <span class="n">dt_array</span><span class="p">,</span>
                <span class="n">tissue</span><span class="o">.</span><span class="n">t1</span><span class="p">,</span> <span class="n">tissue</span><span class="o">.</span><span class="n">t2</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span>
                <span class="n">positions_cm</span><span class="p">,</span> <span class="n">initial_magnetization</span><span class="p">,</span>
                <span class="n">mode</span>
            <span class="p">)</span>
            
        <span class="c1"># Calculate complex signal</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">calculate_signal</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span><span class="p">)</span>
        
        <span class="c1"># Store result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;mx&#39;</span><span class="p">:</span> <span class="n">mx</span><span class="p">,</span>
            <span class="s1">&#39;my&#39;</span><span class="p">:</span> <span class="n">my</span><span class="p">,</span>
            <span class="s1">&#39;mz&#39;</span><span class="p">:</span> <span class="n">mz</span><span class="p">,</span>
            <span class="s1">&#39;signal&#39;</span><span class="p">:</span> <span class="n">signal</span><span class="p">,</span>
            <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span>
            <span class="s1">&#39;positions&#39;</span><span class="p">:</span> <span class="n">positions</span><span class="p">,</span>
            <span class="s1">&#39;frequencies&#39;</span><span class="p">:</span> <span class="n">frequencies</span><span class="p">,</span>
            <span class="s1">&#39;tissue&#39;</span><span class="p">:</span> <span class="n">tissue</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span></div>

    
<div class="viewcode-block" id="BlochSimulator.simulate_phantom">
<a class="viewcode-back" href="../modules.html#bloch_simulator.BlochSimulator.simulate_phantom">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_phantom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phantom</span><span class="p">,</span> <span class="n">sequence</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PulseSequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                        <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
                        <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="n">additional_frequencies</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">use_grouped</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate Bloch equations for a heterogeneous phantom.</span>
<span class="sd">        </span>
<span class="sd">        This method simulates MRI physics for phantoms with spatially-varying</span>
<span class="sd">        tissue properties (T1, T2, proton density, frequency offset). Each voxel</span>
<span class="sd">        can have different parameters, enabling realistic imaging simulation.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        phantom : Phantom</span>
<span class="sd">            Phantom object with tissue property maps (T1, T2, PD, df).</span>
<span class="sd">            See phantom.py for Phantom class and PhantomFactory.</span>
<span class="sd">        sequence : PulseSequence or tuple</span>
<span class="sd">            Either a PulseSequence object or tuple of (b1, gradients, time)</span>
<span class="sd">        dt : float</span>
<span class="sd">            Time step for sequence compilation (if using PulseSequence)</span>
<span class="sd">        mode : int</span>
<span class="sd">            Simulation mode:</span>
<span class="sd">            - 0: Endpoint only (faster, returns final magnetization)</span>
<span class="sd">            - 2: Time-resolved (returns magnetization at all time points)</span>
<span class="sd">        additional_frequencies : ndarray, optional</span>
<span class="sd">            Extra frequency offsets to simulate (Hz). These are added to</span>
<span class="sd">            each voxel&#39;s df_map value. Useful for multi-frequency/spectroscopic</span>
<span class="sd">            imaging.</span>
<span class="sd">        use_grouped : bool</span>
<span class="sd">            If True and phantom has discrete tissue labels, use optimized</span>
<span class="sd">            grouped simulation (faster for segmented phantoms).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Simulation results containing:</span>
<span class="sd">            - &#39;mx&#39;, &#39;my&#39;, &#39;mz&#39;: Magnetization components</span>
<span class="sd">              Shape: (*phantom.shape,) for mode=0, or (ntime, *phantom.shape) for mode=2</span>
<span class="sd">            - &#39;signal&#39;: Complex transverse magnetization (mx + 1j*my)</span>
<span class="sd">            - &#39;time&#39;: Time array from sequence</span>
<span class="sd">            - &#39;phantom&#39;: The input phantom object</span>
<span class="sd">            - &#39;pd_weighted_signal&#39;: Signal weighted by proton density</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from phantom import PhantomFactory</span>
<span class="sd">        &gt;&gt;&gt; # Create Shepp-Logan phantom</span>
<span class="sd">        &gt;&gt;&gt; phantom = PhantomFactory.shepp_logan_2d(64, 0.24, 3.0)</span>
<span class="sd">        &gt;&gt;&gt; # Create excitation pulse</span>
<span class="sd">        &gt;&gt;&gt; seq = PulseSequence()</span>
<span class="sd">        &gt;&gt;&gt; seq.add_rf_pulse(flip_angle=90, duration=1e-3)</span>
<span class="sd">        &gt;&gt;&gt; # Simulate</span>
<span class="sd">        &gt;&gt;&gt; result = simulator.simulate_phantom(phantom, seq, mode=0)</span>
<span class="sd">        &gt;&gt;&gt; # Result shape matches phantom</span>
<span class="sd">        &gt;&gt;&gt; print(result[&#39;mx&#39;].shape)  # (64, 64)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Import Phantom class (avoid circular import)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">phantom</span><span class="w"> </span><span class="kn">import</span> <span class="n">Phantom</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Phantom module not found. Ensure phantom.py is available.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">phantom</span><span class="p">,</span> <span class="n">Phantom</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected Phantom object, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">phantom</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">log_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulating phantom: </span><span class="si">{</span><span class="n">phantom</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Active voxels: </span><span class="si">{</span><span class="n">phantom</span><span class="o">.</span><span class="n">n_active</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">phantom</span><span class="o">.</span><span class="n">nvoxels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Compile sequence</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">PulseSequence</span><span class="p">):</span>
            <span class="n">b1</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b1</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">sequence</span>
        
        <span class="c1"># Prepare arrays (same sanitization as simulate())</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;B1 array must be 1D, got shape </span><span class="si">{</span><span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">b1_gauss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>
        
        <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gradients</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gradients</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">gradients</span> <span class="o">=</span> <span class="n">gradients</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">gradients</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gradients</span> <span class="o">=</span> <span class="n">gradients</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">gradients_gauss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">gradients</span><span class="p">)</span>
        
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        
        <span class="c1"># Time intervals</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dt_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="n">dt_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt_array</span><span class="p">,</span> <span class="n">dt_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dt</span><span class="p">])</span>
        <span class="n">dt_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">dt_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Get phantom properties (active voxels only for efficiency)</span>
        <span class="n">props</span> <span class="o">=</span> <span class="n">phantom</span><span class="o">.</span><span class="n">get_active_properties</span><span class="p">()</span>
        <span class="n">n_active</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;t1&#39;</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">n_active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_message</span><span class="p">(</span><span class="s2">&quot;Warning: No active voxels in phantom (all masked)&quot;</span><span class="p">)</span>
            <span class="c1"># Return zeros</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),)</span> <span class="o">+</span> <span class="n">phantom</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">phantom</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;mx&#39;</span><span class="p">:</span> <span class="n">zeros</span><span class="p">,</span>
                <span class="s1">&#39;my&#39;</span><span class="p">:</span> <span class="n">zeros</span><span class="p">,</span>
                <span class="s1">&#39;mz&#39;</span><span class="p">:</span> <span class="n">zeros</span><span class="p">,</span>
                <span class="s1">&#39;signal&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">),</span>
                <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span>
                <span class="s1">&#39;phantom&#39;</span><span class="p">:</span> <span class="n">phantom</span><span class="p">,</span>
                <span class="s1">&#39;pd_weighted_signal&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">),</span>
            <span class="p">}</span>
        
        <span class="c1"># Convert positions from meters to cm (Bloch core uses Gauss/cm)</span>
        <span class="n">positions_cm</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span>  <span class="c1"># m -&gt; cm</span>
        <span class="n">positions_cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">positions_cm</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Frequency offsets</span>
        <span class="n">df_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;df&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Initial magnetization</span>
        <span class="n">m_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;m0&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Check memory requirements</span>
        <span class="n">ntout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">total_samples</span> <span class="o">=</span> <span class="n">ntout</span> <span class="o">*</span> <span class="n">n_active</span>
        <span class="k">if</span> <span class="n">total_samples</span> <span class="o">&gt;</span> <span class="mf">1e8</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Phantom simulation too large (</span><span class="si">{</span><span class="n">total_samples</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2"> samples for </span><span class="si">{</span><span class="n">n_active</span><span class="si">}</span><span class="s2"> active voxels). &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Use smaller phantom, reduce time points, or use endpoint mode (mode=0).&quot;</span>
            <span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">log_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulation size: </span><span class="si">{</span><span class="n">n_active</span><span class="si">}</span><span class="s2"> voxels × </span><span class="si">{</span><span class="n">ntout</span><span class="si">}</span><span class="s2"> time points = </span><span class="si">{</span><span class="n">total_samples</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2"> samples&quot;</span><span class="p">)</span>
        
        <span class="c1"># Import wrapper function</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">bloch_simulator_cy</span><span class="w"> </span><span class="kn">import</span> <span class="n">simulate_phantom</span> <span class="k">as</span> <span class="n">simulate_phantom_core</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;bloch_simulator_cy not compiled. Run: python setup.py build_ext --inplace&quot;</span><span class="p">)</span>
        
        <span class="c1"># Run simulation</span>
        <span class="n">t1_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;t1&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">t2_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;t2&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">log_message</span><span class="p">(</span><span class="s2">&quot;Running heterogeneous Bloch simulation...&quot;</span><span class="p">)</span>
        <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span> <span class="o">=</span> <span class="n">simulate_phantom_core</span><span class="p">(</span>
            <span class="n">b1_gauss</span><span class="p">,</span> <span class="n">gradients_gauss</span><span class="p">,</span> <span class="n">dt_array</span><span class="p">,</span>
            <span class="n">t1_array</span><span class="p">,</span> <span class="n">t2_array</span><span class="p">,</span> <span class="n">df_array</span><span class="p">,</span>
            <span class="n">positions_cm</span><span class="p">,</span> <span class="n">m_init</span><span class="p">,</span>
            <span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span>
        <span class="p">)</span>
        
        <span class="c1"># Reconstruct full phantom shape from active voxels</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Time-resolved: (ntime, n_active) -&gt; (ntime, *phantom.shape)</span>
            <span class="n">mx_full</span> <span class="o">=</span> <span class="n">phantom</span><span class="o">.</span><span class="n">reconstruct_from_active</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">has_time</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">my_full</span> <span class="o">=</span> <span class="n">phantom</span><span class="o">.</span><span class="n">reconstruct_from_active</span><span class="p">(</span><span class="n">my</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">has_time</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">mz_full</span> <span class="o">=</span> <span class="n">phantom</span><span class="o">.</span><span class="n">reconstruct_from_active</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">has_time</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Endpoint: (n_active,) -&gt; (*phantom.shape,)</span>
            <span class="n">mx_full</span> <span class="o">=</span> <span class="n">phantom</span><span class="o">.</span><span class="n">reconstruct_from_active</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">has_time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">my_full</span> <span class="o">=</span> <span class="n">phantom</span><span class="o">.</span><span class="n">reconstruct_from_active</span><span class="p">(</span><span class="n">my</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">has_time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">mz_full</span> <span class="o">=</span> <span class="n">phantom</span><span class="o">.</span><span class="n">reconstruct_from_active</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">has_time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        
        <span class="c1"># Complex signal per voxel (image-space magnetization)</span>
        <span class="n">signal_per_voxel</span> <span class="o">=</span> <span class="n">mx_full</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">my_full</span>
        
        <span class="c1"># Apply proton density weighting</span>
        <span class="n">pd_map</span> <span class="o">=</span> <span class="n">phantom</span><span class="o">.</span><span class="n">pd_map</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Broadcast pd_map to (ntime, *shape)</span>
            <span class="n">pd_weighted</span> <span class="o">=</span> <span class="n">signal_per_voxel</span> <span class="o">*</span> <span class="n">pd_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pd_weighted</span> <span class="o">=</span> <span class="n">signal_per_voxel</span> <span class="o">*</span> <span class="n">pd_map</span>
        
        <span class="c1"># Calculate RECEIVED SIGNAL (sum over all voxels)</span>
        <span class="c1"># This is what an RF coil would measure - the coherent sum of all spins</span>
        <span class="c1"># S(t) = Σ [Mxy(r,t) * PD(r)] for all positions r</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Time-resolved: sum over spatial dimensions, keep time</span>
            <span class="c1"># pd_weighted shape: (ntime, *spatial_shape)</span>
            <span class="n">spatial_axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pd_weighted</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">received_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pd_weighted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">spatial_axes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Received signal shape: </span><span class="si">{</span><span class="n">received_signal</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> (sum over </span><span class="si">{</span><span class="n">pd_weighted</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Endpoint: sum over all spatial dimensions</span>
            <span class="n">received_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pd_weighted</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Received signal (endpoint): </span><span class="si">{</span><span class="n">received_signal</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Store result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;mx&#39;</span><span class="p">:</span> <span class="n">mx_full</span><span class="p">,</span>
            <span class="s1">&#39;my&#39;</span><span class="p">:</span> <span class="n">my_full</span><span class="p">,</span>
            <span class="s1">&#39;mz&#39;</span><span class="p">:</span> <span class="n">mz_full</span><span class="p">,</span>
            <span class="s1">&#39;signal&#39;</span><span class="p">:</span> <span class="n">signal_per_voxel</span><span class="p">,</span>           <span class="c1"># Per-voxel signal (for imaging)</span>
            <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span>
            <span class="s1">&#39;phantom&#39;</span><span class="p">:</span> <span class="n">phantom</span><span class="p">,</span>
            <span class="s1">&#39;pd_weighted_signal&#39;</span><span class="p">:</span> <span class="n">pd_weighted</span><span class="p">,</span>    <span class="c1"># Per-voxel signal * PD</span>
            <span class="s1">&#39;received_signal&#39;</span><span class="p">:</span> <span class="n">received_signal</span><span class="p">,</span>   <span class="c1"># Total signal (what coil measures)</span>
        <span class="p">}</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">log_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulation complete. Output shape: </span><span class="si">{</span><span class="n">mx_full</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span></div>

    
<div class="viewcode-block" id="BlochSimulator.plot_magnetization">
<a class="viewcode-back" href="../modules.html#bloch_simulator.BlochSimulator.plot_magnetization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_magnetization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> 
                          <span class="n">position_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                          <span class="n">freq_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot magnetization evolution.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        component : str</span>
<span class="sd">            &#39;mx&#39;, &#39;my&#39;, &#39;mz&#39;, &#39;magnitude&#39;, or &#39;all&#39;</span>
<span class="sd">        position_idx : int</span>
<span class="sd">            Position index to plot</span>
<span class="sd">        freq_idx : int</span>
<span class="sd">            Frequency index to plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No simulation results available&quot;</span><span class="p">)</span>
            
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;mx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Single time point</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Single time point result - no time evolution to plot&quot;</span><span class="p">)</span>
            <span class="k">return</span>
            
        <span class="c1"># Extract data for specific position and frequency</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;mx&#39;</span><span class="p">][:,</span> <span class="n">position_idx</span><span class="p">,</span> <span class="n">freq_idx</span><span class="p">]</span>
        <span class="n">my</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;my&#39;</span><span class="p">][:,</span> <span class="n">position_idx</span><span class="p">,</span> <span class="n">freq_idx</span><span class="p">]</span>
        <span class="n">mz</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;mz&#39;</span><span class="p">][:,</span> <span class="n">position_idx</span><span class="p">,</span> <span class="n">freq_idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;result = </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Debugging line</span>
        
        <span class="c1"># Create plot</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        
        <span class="c1"># Mx</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">mx</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Mx&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Transverse Magnetization (x)&#39;</span><span class="p">)</span>
        
        <span class="c1"># My</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">my</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;My&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Transverse Magnetization (y)&#39;</span><span class="p">)</span>
        
        <span class="c1"># Mz</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">mz</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Mz&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Longitudinal Magnetization&#39;</span><span class="p">)</span>
        
        <span class="c1"># Magnitude</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">my</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;|Mxy|&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Transverse Magnitude&#39;</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Magnetization Evolution</span><span class="se">\n</span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;tissue&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

        
<div class="viewcode-block" id="BlochSimulator.save_results">
<a class="viewcode-back" href="../modules.html#bloch_simulator.BlochSimulator.save_results">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sequence_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">simulation_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save simulation results to HDF5 file with complete parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Output HDF5 filename</span>
<span class="sd">        sequence_params : dict, optional</span>
<span class="sd">            Pulse sequence parameters (TE, TR, flip angle, etc.)</span>
<span class="sd">        simulation_params : dict, optional</span>
<span class="sd">            Simulation settings (mode, dt, parallel settings, etc.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No simulation results available&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># Save magnetization data</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mx&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;mx&#39;</span><span class="p">])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;my&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;my&#39;</span><span class="p">])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mz&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;mz&#39;</span><span class="p">])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">])</span>

            <span class="c1"># Save parameters</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;positions&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;frequencies&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;frequencies&#39;</span><span class="p">])</span>

            <span class="c1"># Save tissue parameters</span>
            <span class="n">tissue_group</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;tissue&#39;</span><span class="p">)</span>
            <span class="n">tissue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span>
            <span class="n">tissue_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tissue</span><span class="o">.</span><span class="n">name</span>
            <span class="n">tissue_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;t1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tissue</span><span class="o">.</span><span class="n">t1</span>
            <span class="n">tissue_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;t2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tissue</span><span class="o">.</span><span class="n">t2</span>
            <span class="n">tissue_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tissue</span><span class="o">.</span><span class="n">density</span>
            <span class="k">if</span> <span class="n">tissue</span><span class="o">.</span><span class="n">t2_star</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tissue_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;t2_star&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tissue</span><span class="o">.</span><span class="n">t2_star</span>

            <span class="c1"># Save pulse sequence parameters if provided</span>
            <span class="k">if</span> <span class="n">sequence_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">seq_group</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;sequence_parameters&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">sequence_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                            <span class="n">seq_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">seq_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c1"># Save simulation parameters if provided</span>
            <span class="k">if</span> <span class="n">simulation_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sim_group</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;simulation_parameters&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">simulation_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                            <span class="n">sim_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">sim_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c1"># Add metadata</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;export_timestamp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;simulator_version&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1.0.0&#39;</span></div>


<div class="viewcode-block" id="BlochSimulator.save_parameters_json">
<a class="viewcode-back" href="../modules.html#bloch_simulator.BlochSimulator.save_parameters_json">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_parameters_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sequence_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">simulation_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">include_waveforms</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save simulation parameters to JSON file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Output JSON filename</span>
<span class="sd">        sequence_params : dict, optional</span>
<span class="sd">            Pulse sequence parameters</span>
<span class="sd">        simulation_params : dict, optional</span>
<span class="sd">            Simulation settings</span>
<span class="sd">        include_waveforms : bool, optional</span>
<span class="sd">            If True, include RF pulse and gradient waveforms (can be large)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No simulation results available&quot;</span><span class="p">)</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

        <span class="n">params_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;metadata&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;export_timestamp&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">)),</span>
                <span class="s1">&#39;simulator_version&#39;</span><span class="p">:</span> <span class="s1">&#39;1.0.0&#39;</span>
            <span class="p">},</span>
            <span class="s1">&#39;tissue_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s1">&#39;t1&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">t1</span><span class="p">),</span>
                <span class="s1">&#39;t2&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">t2</span><span class="p">),</span>
                <span class="s1">&#39;density&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">density</span><span class="p">),</span>
                <span class="s1">&#39;t2_star&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">t2_star</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">t2_star</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="p">},</span>
            <span class="s1">&#39;positions&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s1">&#39;frequencies&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;frequencies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s1">&#39;time_points&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])),</span>
            <span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_result</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="p">}</span>

        <span class="c1"># Add sequence parameters</span>
        <span class="k">if</span> <span class="n">sequence_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params_dict</span><span class="p">[</span><span class="s1">&#39;sequence_parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">sequence_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">include_waveforms</span><span class="p">:</span>
                            <span class="n">params_dict</span><span class="p">[</span><span class="s1">&#39;sequence_parameters&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">params_dict</span><span class="p">[</span><span class="s1">&#39;sequence_parameters&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;array shape=</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                        <span class="n">params_dict</span><span class="p">[</span><span class="s1">&#39;sequence_parameters&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">params_dict</span><span class="p">[</span><span class="s1">&#39;sequence_parameters&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># Add simulation parameters</span>
        <span class="k">if</span> <span class="n">simulation_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params_dict</span><span class="p">[</span><span class="s1">&#39;simulation_parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">simulation_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="n">params_dict</span><span class="p">[</span><span class="s1">&#39;simulation_parameters&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                        <span class="n">params_dict</span><span class="p">[</span><span class="s1">&#39;simulation_parameters&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">params_dict</span><span class="p">[</span><span class="s1">&#39;simulation_parameters&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># Write to file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">params_dict</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="BlochSimulator.load_results">
<a class="viewcode-back" href="../modules.html#bloch_simulator.BlochSimulator.load_results">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load simulation results from HDF5 file.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_result</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;mx&#39;</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;mx&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">],</span>
                <span class="s1">&#39;my&#39;</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;my&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">],</span>
                <span class="s1">&#39;mz&#39;</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;mz&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">],</span>
                <span class="s1">&#39;signal&#39;</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">],</span>
                <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">],</span>
                <span class="s1">&#39;positions&#39;</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">],</span>
                <span class="s1">&#39;frequencies&#39;</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;frequencies&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">],</span>
                <span class="s1">&#39;tissue&#39;</span><span class="p">:</span> <span class="n">TissueParameters</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
                    <span class="n">t1</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;t1&#39;</span><span class="p">],</span>
                    <span class="n">t2</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;t2&#39;</span><span class="p">],</span>
                    <span class="n">density</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;tissue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;density&#39;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">}</span></div>
</div>



<span class="c1"># Example usage functions</span>
<div class="viewcode-block" id="example_fid">
<a class="viewcode-back" href="../modules.html#bloch_simulator.example_fid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">example_fid</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Example: Free Induction Decay simulation.&quot;&quot;&quot;</span>
    <span class="c1"># Create simulator</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">BlochSimulator</span><span class="p">()</span>
    
    <span class="c1"># Define tissue</span>
    <span class="n">tissue</span> <span class="o">=</span> <span class="n">TissueParameters</span><span class="o">.</span><span class="n">gray_matter</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
    
    <span class="c1"># Simple FID sequence</span>
    <span class="n">ntime</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mf">1e-5</span>  <span class="c1"># 10 microseconds</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ntime</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
    
    <span class="c1"># 90-degree pulse</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ntime</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c1"># Short hard pulse</span>
    
    <span class="c1"># No gradients</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntime</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    
    <span class="c1"># Single position, multiple frequencies</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>  <span class="c1"># -100 to 100 Hz</span>
    
    <span class="c1"># Simulate</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
        <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">time</span><span class="p">),</span>
        <span class="n">tissue</span><span class="p">,</span>
        <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span>
        <span class="n">frequencies</span><span class="o">=</span><span class="n">frequencies</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="mi">2</span>  <span class="c1"># Time-resolved</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="example_spin_echo">
<a class="viewcode-back" href="../modules.html#bloch_simulator.example_spin_echo">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">example_spin_echo</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Example: Spin echo simulation.&quot;&quot;&quot;</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">BlochSimulator</span><span class="p">()</span>
    
    <span class="c1"># Create spin echo sequence</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="n">SpinEcho</span><span class="p">(</span><span class="n">te</span><span class="o">=</span><span class="mf">20e-3</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">500e-3</span><span class="p">)</span>
    
    <span class="c1"># Define tissue</span>
    <span class="n">tissue</span> <span class="o">=</span> <span class="n">TissueParameters</span><span class="o">.</span><span class="n">white_matter</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
    
    <span class="c1"># Simulate</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">tissue</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bloch Simulator Python API&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;==========================&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This module provides high-level functions for MRI simulation.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Example usage:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  from bloch_simulator import BlochSimulator, TissueParameters&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  sim = BlochSimulator()&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  tissue = TissueParameters.gray_matter(3.0)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  # ... define sequence ...&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  result = sim.simulate(sequence, tissue)&quot;</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Luca Nagel.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>